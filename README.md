## singleflight

**singleflight** — это небольшая Go‑библиотека для дедупликации запросов и опциональный in‑memory‑кеш с TTL и поддержкой прогрева.

- **Дедупликация по ключу**: конкурентные запросы с одинаковым ключом выполняют `fn` ровно один раз и разделяют результат.
- **Опциональный кеш**: результаты запросов могут кешироваться в памяти на настраиваемый TTL, чтобы сократить количество вызовов `fn`.
- **Прогрев (warm‑up)**: перед истечением TTL значение может быть заранее пересчитано в фоне, чтобы запросы всегда быстро получали готовое значение из кеша.

![singleflight+cache timeline](https://raw.githubusercontent.com/kozhurkin/singleflight/main/doc/timeline.png)

## Пример использования в HTTP‑сервисе

В `cmd/example/main.go` показан реальный сценарий: сервис погоды, который ходит к внешнему API и кеширует результат по городу:

```go
// Кеш: TTL 5 секунд, ошибки не кешируем (errorTTL = 0), окно прогрева 2 секунды.
resultTTL, errorTTL, warmupWindow := 5*time.Second, 0, 2*time.Second
cache := singleflight.NewGroupWithCache[string, Weather](resultTTL, errorTTL, warmupWindow)

mux.HandleFunc("/weather", func(w http.ResponseWriter, r *http.Request) {
    city := r.URL.Query().Get("city")
    weather, err := cache.Do(city, func() (Weather, error) {
        return fetchWeather(city) // один HTTP‑запрос на город
    })

    // ... encode weather to JSON ...
})
```

Даже при большом количестве параллельных запросов к `/weather?city=st.petersburg`:

- внешний API вызывается один раз на всю «волну» запросов;
- результат кешируется на время TTL;
- перед истечением TTL значение может быть заранее обновлено за счёт прогрева;
- если запросы к ресурсу прекращаются, ключ удаляется из кеша.

---

## Какую проблему решает singleflight

Во многих сервисах есть «дорогие» операции:

- запросы к внешним HTTP‑API;
- тяжёлые SQL/NoSQL‑запросы;
- вычислительные функции (кастомные отчёты, агрегации и т.п.).

Если несколько горутин почти одновременно запросят один и тот же ресурс, без координации вы получите дублирующие запросы и лишнюю нагрузку.

`singleflight.Group` решает это так:

- по ключу `key` запускается ровно **одно** выполнение `fn`;
- все конкурентные вызовы `Do(key, fn)` ждут этого выполнения и получают **один и тот же результат**;
- опционально результат кладётся в кеш на `resultTTL`, чтобы вообще не дёргать `fn` в течение TTL.
- TODO про окно прогрева.

---

## Чем эта реализация выгодно отличается от стандартной

По сравнению с `golang.org/x/sync/singleflight` наша реализация добавляет:

- **Явное кеширование с TTL**:
  - стандартный `singleflight` только дедуплицирует конкурентные вызовы, но не кеширует результаты;
  - здесь есть `NewGroupWithCache(resultTTL, errorTTL, warmupWindow)`, позволяющий использовать `Group` как лёгкий in‑memory кеш с дедупликацией.
- **Управление кешированием ошибок**:
  - параметр `errorTTL` позволяет включать/выключать кеширование ошибок и задавать отдельный TTL;
  - типичный кейс — **не** кешировать временные сетевые ошибки, но кешировать бизнес‑ошибки (например, «пользователь не найден»).
- **Поддержка прогрева (warm‑up)**:
  - по истечении `resultTTL` ключ не сразу выбрасывается;
  - при первом следующем запросе:
    - старое значение ещё какое‑то время отдаётся клиентам;
    - параллельно запускается «разогрев» (`warm`‑вычисление);
  - после `warmupWindow` его результат применяется, и все следующие вызовы получают уже прогретое значение;
  - это сглаживает пики нагрузки и защищает от «штормов кэша» (cache stampede).

При этом API остаётся простым, совместимым по идее со стандартным `singleflight.Group`.

---

## Установка

```bash
go get github.com/kozhurkin/singleflight
```

Репозиторий: [github.com/kozhurkin/singleflight](https://github.com/kozhurkin/singleflight)

---

## API


#### Конструктор без кеша (только дедупликация):

```go
func NewGroup[K comparable, V any]() *Group[K, V]
```
#### Конструктор с кешем и прогревом**:

```go
func NewGroupWithCache[K comparable, V any](
    resultTTL    time.Duration, // TTL успешного значения
    errorTTL     time.Duration, // TTL ошибок (0 — ошибки не кешируются)
    warmupWindow time.Duration, // окно прогрева
) *Group[K, V]
```

#### Основной метод: `Do`

```go
func (g *Group[K, V]) Do(
    key K,
    fn func() (V, error),
) (V, error)
```