## singleflight

**singleflight** — это небольшая Go‑библиотека для дедупликации запросов и опциональный in‑memory‑кеш с TTL и поддержкой прогрева.

- **Дедупликация по ключу**: конкурентные запросы с одинаковым ключом выполняют `fn` ровно один раз и разделяют результат.
- **Опциональный кеш** с TTL и поддержкой **прогрева (warm‑up)**.
- **Генерики для ключа и значения** (`Group[K comparable, V any]`).

---


## Пример использования в HTTP‑сервисе

В `cmd/example/main.go` показан реальный сценарий: сервис погоды, который ходит к внешнему API и кеширует результат по городу:

```go
// Кеш: TTL 5 секунд, ошибки не кешируем, прогрев 2 секунды.
cache := singleflight.NewGroupWithCache[string, Weather](5*time.Second, false, 2*time.Second)

mux.HandleFunc("/weather", func(w http.ResponseWriter, r *http.Request) {
    city := r.URL.Query().Get("city")
    weather, err := cache.Do(city, func() (Weather, error) {
        return fetchWeather(city) // один HTTP‑запрос на город
    })

    // ... encode weather to JSON ...
})
```

Даже при большом количестве параллельных запросов к `/weather?city=spb`:

- внешний API вызывается один раз на всю «волну» запросов;
- результат кешируется на время TTL;
- перед истечением TTL значение может быть заранее обновлено за счёт прогрева;
- если запросы к ресурсу прекращаются, ключ удаляется из кеша и больше не прогревается.

---

## Какую проблему решает singleflight

Во многих сервисах есть «дорогие» операции:

- запросы к внешним HTTP‑API;
- тяжёлые SQL/NoSQL‑запросы;
- вычислительные функции (кастомные отчёты, агрегации и т.п.).

Если несколько горутин почти одновременно запросят один и тот же ресурс, без координации вы получите дублирующие запросы и лишнюю нагрузку.

`singleflight.Group` решает это так:

- по ключу `key` запускается ровно **одно** выполнение `fn`;
- все конкурентные вызовы `Do(key, fn)` ждут этого выполнения и получают **один и тот же результат**;
- опционально результат кладётся в кеш на `cacheTime`, чтобы вообще не дёргать `fn` в течение TTL.

---

## Чем эта реализация выгодно отличается от стандартной

По сравнению с `golang.org/x/sync/singleflight` наша реализация добавляет:

- **Явное кеширование с TTL**:
  - стандартный `singleflight` только дедуплицирует конкурентные вызовы, но не кеширует результаты;
  - здесь есть `NewGroupWithCache(cacheTime, cacheErrors, warmTime)`, позволяющий использовать `Group` как лёгкий in‑memory кеш с дедупликацией.
- **Управление кешированием ошибок**:
  - флаг `cacheErrors` позволяет включать/выключать кеширование ошибок;
  - типичный кейс — **не** кешировать временные сетевые ошибки, но кешировать бизнес‑ошибки (например, «пользователь не найден»).
- **Поддержка прогрева (warm‑up)**:
  - по истечении `cacheTime` ключ не сразу выбрасывается;
  - при первом следующем запросе:
    - старое значение ещё какое‑то время отдаётся клиентам;
    - параллельно запускается «разогрев» (`warm`‑вычисление);
    - после `warmTime` его результат применяется, и все следующие вызовы получают уже прогретое значение;
  - это сглаживает пики нагрузки и защищает от «штормов кэша» (cache stampede).

При этом API остаётся простым, совместимым по идее со стандартным `singleflight.Group`.

---

## Установка

```bash
go get github.com/your-org/singleflight
```

> Замените `github.com/your-org/singleflight` на реальный импортный путь вашего модуля.

---

## API


#### Конструкторы

- **Без кеша (только дедупликация)**:

```go
func NewGroup[K comparable, V any]() *Group[K, V]
```

Создаёт группу, которая:

- дедуплицирует **только конкурентные** вызовы;
- каждый последующий вызов после завершения предыдущего **снова вызывает** `fn`.

- **С кешем и прогревом**:

```go
func NewGroupWithCache[K comparable, V any](
    cacheTime   time.Duration, // TTL значения
    cacheErrors bool,          // кешировать ли ошибки
    warmTime    time.Duration, // окно прогрева
) *Group[K, V]
```

- `cacheTime > 0` — включён кеш, результаты (и опционально ошибки) живут `cacheTime`;
- `cacheErrors = false` — ошибки не кешируются, каждый новый вызов после ошибки заново выполняет `fn`;
- `cacheErrors = true` — ошибки живут в кеше так же, как и успешные результаты;
- `warmTime > 0` — включён режим прогрева (warm‑up).

#### Основной метод: `Do`

```go
func (g *Group[K, V]) Do(
    key K,
    fn func() (V, error),
) (V, error)
```

- Если по `key` уже идёт вычисление — текущая горутина ждёт его (`Wait`) и возвращает результат.
- Если по `key` есть закешированный результат с неистёкшим `cacheTime` — он возвращается **без вызова `fn`**.
- Если кеш пустой или протух:
  - `fn` выполняется один раз;
  - результат кладётся в кеш (если `cacheTime > 0` и, для ошибок, `cacheErrors == true`).

Поведение в разных режимах:

- **`cacheTime == 0`** — поведение как у «чистого» singleflight: только дедупликация конкурентных вызовов, без кеша.
- **`cacheErrors == false`** — ошибки не кешируются: каждый новый вызов после ошибки снова вызывает `fn`.
- **`warmTime == 0`** — кэш сбрасывается сразу по TTL, без прогрева.

---

## Примеры использования

### 1. Простая дедупликация без кеша

```go
package main

import (
    "fmt"
    "sync"
    "time"

    "singleflight"
)

func main() {
    g := singleflight.NewGroup[string, int]()

    var wg sync.WaitGroup
    for i := 0; i < 10; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            v, err := g.Do("answer", func() (int, error) {
                // Эта функция реально будет вызвана только один раз
                time.Sleep(50 * time.Millisecond)
                fmt.Println("fn called")
                return 42, nil
            })
            if err != nil {
                fmt.Println("err:", err)
                return
            }
            fmt.Println("value:", v)
        }()
    }

    wg.Wait()
}
```

Вывод покажет одну строку `fn called` и 10 строк `value: 42`.

---

### 2. Дедупликация + кеширование результата

```go
// TTL 5 секунд, ошибки не кешируем, прогрев отключён.
g := singleflight.NewGroupWithCache[string, string](5*time.Second, false, 0)

getUser := func(id string) (string, error) {
    return g.Do(id, func() (string, error) {
        // здесь может быть запрос к БД/внешнему API
        fmt.Println("query for id =", id)
        return "user-" + id, nil
    })
}

// Первый вызов реально выполнит fn.
u1, _ := getUser("42")

// В течение 5 секунд следующий вызов вернёт кеш.
time.Sleep(4*time.Second)
u2, _ := getUser("42")
```

`"query for id = 42"` будет напечатано только один раз.

---

### 3. Кеширование с прогревом (warm‑up)

```go
// TTL 5 секунд, ошибки не кешируем, окно прогрева 2 секунды.
g := singleflight.NewGroupWithCache[string, int](5*time.Second, false, 2*time.Second)

// Первый вызов вычисляет и кеширует значение 1.
v1, _ := g.Do("key", func() (int, error) {
    fmt.Println("compute initial")
    return 1, nil
})

// Через ~5 секунд TTL истекает, но ключ сразу не удаляется.
time.Sleep(5*time.Second + 10*time.Millisecond)

// Этот вызов ещё вернёт старое значение (1),
// но в фоне запустит «разогрев» с новым fn.
v2, _ := g.Do("key", func() (int, error) {
    fmt.Println("warm compute")
    return 2, nil
})

// Даём прогреву завершиться.
time.Sleep(2*time.Second + 10*time.Millisecond)

// Теперь значение должно быть обновлённым (2).
v3, _ := g.Do("key", func() (int, error) {
    fmt.Println("should not be called, warm value used")
    return 3, nil
})

fmt.Println(v1, v2, v3) // 1 1 2
```

---

## Тесты

Библиотека покрыта юнит‑тестами:

- `singleflight_test.go` — сценарии дедупликации, кеша, кеширования ошибок, прогрева и очистки ключей.

Запуск:

```bash
go test ./...
```


